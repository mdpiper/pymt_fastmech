[CGNSFile]
    # Use iRIC produced .cgns file: (0) no; (1) all; (2) grid only:
    use_cgn = {{use_cgn}}

    # if use_cgn == 1 or 2: path and filename of .cgns file:
    cgnsfile = {{cgnsfile}}

[Discharge]
    # Discharge Type (Enumeration): (0) Single valued, (1) Variable:
    discharge_type = {{discharge_type}}

    # Single valued discharge (m^3/s):
    discharge = {{discharge}}

    # Velocity depth weighting coefficient:
    vdc = {{vdc}}

    # Velocity angle relative to boundary (degrees):
    vac = {{vac}}

    # If discharge_type == 1: Discharge array (m^3/s):
    vvalue = {{vvalue}}

    # If discharge_type == 1:Time array (s):
    vparam = {{vparam}}

[Stage]
    # Stage type (Enumeration): (0) single valued, (1) time-series, (2) rating-curve:
    stage_type = {{stage_type}}

    # If stage_type == 0: Single valued Stage (m):
    stage = {{stage}}

    # If stage_type == 1 or 2: Stage Value(Stage type): (1) stage (m); (2) stage (m); array:
    svalue = {{svalue}}

    # If stage_type == 1 or 2: Stage Param(Stage type): (1) time (s); (2) discharge (m^3/s); array):
    sparam = {{sparam}}

[Roughness]
    # Roughness type: (0) drag Coefficient; (1) znaught:
    roughness_type = {{roughness_type}}

    # Distribution type: (0) single valued; (1) spatially distributed:
    distribution_type = {{distribution_type}}

    # If roughness_type == 0: single value of roughness(roughness type): (0) Cd; (1) znaught:
    roughness = {{roughness}}

    # If roughness_type == 1: Cd max value(roughness type): (0) Cd; (1) znaught:
    cdmin = {{cdmin}}

    # If roughness_type == 1: Cd min value(roughness type): (0) Cd; (1) znaught:
    cdmax = {{cdmax}}

[Lateral_eddy_viscosity]
    # Lateral Eddy Viscosity (LEV) type: (0) single valued; (1) varialble over iteration:
    lev_type = {{lev_type}}

    # If lev_type == 1: Iteration to begin change:
    start_iteration = {{start_iteration}}

    # If lev_type == 1: Iteration to end change:
    end_iteration = {{end_iteration}}

    # If lev_type == 1: Starting value of LEV. Begins to change at start_iteration:
    start_value = {{start_value}}

    # If lev_typee == 1: Ending value of LEV. Value at end_iteration:
    end_value = {{end_value}}

    # If lev_type == 0: Single value of LEV:
    lev = {{lev}}

[Grid_extension]
    # Number of streamwise nodes to extend grid at downstream boundary:
    ext_numnodes = {{ext_numnodes}}

    # if ext_numnodes > 0: slope to extend downstream boundary elevation:
    ext_slope = {{ext_slope}}

    # Condition of velocity at downstream boundary: (0) normal; (1) force no-recirculation:
    down_stream_boundary = {{down_stream_boundary}}

[initial_wse_conditions]
    # Initial water-surface elevation (wse) type: (0) upstream-stage; (1) uniform-slope; (2) 1d step-backwater; (3) hot start:
    init_wse_type = {{init_wse_type}}

    # If init_wse_type == 0: upstream-stage value (m):
    upstream_stage =  {{upstream_stage}}

    # If init_wse_type == 1: uniform slope  value (m/m):
    uniform_slope = {{uniform_slope}}

    # If init_wse_type == 2: Cd for 1d step-backwater value (Cd):
    oned_cd = {{oned_cd}}

    # Output hot-start files: (0) no; (1) yes:
    hs_output = {{hs_output}}

    # If Output hot-start files == 1: path/to/hotstartfile/:
    hs_file_path = {{hs_file_path}}

    # If Output hot-start files == 1: time to write hot-start file:
    hs_times = {{hs_times}}

    # If hs_output == 1: hotstart filename:
    hs_file = {{hs_file}}

[wetting_and_drying]
    # Drying type: (0) set node off; (1) set node to drying depth:
    drying_type = {{drying_type}}

    # Drying depth (typically 0.0) (m):
    drying_depth = {{drying_depth}}

    # Calculate rewetting: (F) No; (T) yes:
    calc_rewetting = {{calc_rewetting}}

    # If calc_rewetting == 1: Rewetting depth (typically 0.015) (m):
    rewetting_depth = {{rewetting_depth}}

    # If calc_rewetting == 1: Iteration interval to check rewetting:
    check_rewetting_iter = {{check_rewetting_iter}}

    # If calc_rewetting == 1: Iteration to stop check rewetting:
    iter_stop_checking = {{iter_stop_checking}}

[solution_parameters]
    # Solution type: (0) constant discharge; (1) time-varying discharge:
    solution_type = {{solution_type}}

    # Number of initial iterations:
    num_iterations = {{num_iterations}}

    # Write solution during initial iteration: (F) no (typical) (T) yes:
    iter_solution_out = {{iter_solution_out}}

    # If iter_sol_out == 1: iteration interval to write solution:
    iter_solution_inc = {{iter_solution_inc}}

    # If solution_type == 1: start time (s):
    start_time = {{start_time}}

    # If solution_type == 1: end time (s):
    end_time = {{end_time}}

    # If solution_type == 1: time-step (s):
    time_step = {{time_step}}

    # If solution_type == 1: iteration between time-steps:
    time_step_iter = {{time_step_iter}} 

    # If solution_type == 1: time-step increment to save solution (s):
    plot_inc = {{plot_inc}}

    # If solution_type == 1: multiplyer of iteration between time-steps (increases time_step_iter if a large number of nodes become dry or wet):
    iter_multiplyer = {{iter_multiplyer}}

    # Stop and write solution for debugging: (0) no; (1) yes:
    debug_stop = {{debug_stop}}

    # If debug_stop == 1: time-step to stop solution:
    debug_time_step = {{debug_time_step}}

    # If debug_stop == 1: iteration to stop solution at debug_time_step:
    debug_iteration = {{debug_iteration}}

    # WSE relaxation coefficient:
    erelax = {{erelax}}

    # Velocity relaxation coefficient:
    urelax = {{urelax}}

    # Slope relaxation coefficient:
    arelax = {{arelax}}

[2d_solution_output]
    # Output velocity (streamwise and normal relative to grid): (F) no; (T) yes:
    velocitysn = {{velocitysn}}

    # Output boundary shear stress: (F) no; (T) yes:
    shearstressxy = {{shearstressxy}}

    # Output boundary shear stress (streamwise and normal relative to grid): (F) no; (T) yes:
    shearstresssn = {{shearstresssn}}

    # Output drag coefficient: (F) no; (T) yes:
    cd = {{cd}}

    # Output area associated with each node (usefull when calculating habitat params): (F) no; (T) yes:
    area = {{area}}

    # Output unit discharge: (F) no; (T) yes:
    unit_discharge = {{unit_discharge}}

[quasi3d_solution]
    # Calculate quasi-three-dimensional solution: (0) no; (1) yes:
    quasi_3d = {{quasi_3d}}

    # if quasi_3d == true: number of vertical nodes:
    nz = {{nz}}

    # if quasi_3d == true: use streamline curvature:
    streamline_curv = {{streamline_curv}}

    # if quasi_3d == true: minimum radius of streamline curvature:
    min_streamline_curv = {{min_streamline_curv}}

[Grid]
    # Grid number of nodes in the streamwise direction:
    ns = {{ns}}

    # Grid number of nodes in the cross-stream direction:
    nn = {{nn}}

    # Grid_x:
    x =  {{grid_x}}

    # Grid_y:
    y = {{grid_y}}

    # Grid_elevation:
    elev =  {{grid_elev}}

    # Grid_roughness (Cd):
    cd =  {{grid_roughness}}

    # Grid_znaught (m):
    znaught =  {{grid_znaught}}

    # Grid_veg_roughness (Cd):
    vegcd = {{grid_vegcd}}
